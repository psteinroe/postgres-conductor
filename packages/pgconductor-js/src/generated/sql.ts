/* This file is auto-generated by `just build-migrations`; DO NOT EDIT */
export const getMigrations = (schemaName: string) => ({
  "0000000000_migrations.sql": String.raw`
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'uuid-ossp') THEN
    RAISE EXCEPTION 'Extension uuid-ossp is not installed. Run: CREATE EXTENSION "uuid-ossp";';
  END IF;
END $$;

CREATE SCHEMA IF NOT EXISTS pgconductor;

CREATE TABLE pgconductor.schema_migrations (
  version INT PRIMARY KEY,
  name TEXT NOT NULL,
  applied_at TIMESTAMP DEFAULT NOW(),
  breaking boolean default false
);
`,
  "0000000001_setup.sql": String.raw`
-- todo:
-- - throttling (limit, period, key),
-- - concurrency (limit, key),
-- - rateLimit (limit, period, key),
-- - debounce (period, key) -> via invoke
-- throttling, concurrency and rateLimit: key and seconds - fetch and group by - USE SLOTS similar to https://planetscale.com/blog/the-slotted-counter-pattern
-- batch processing via array payloads?

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Returns either the actual current timestamp or a fake one for tests.
-- Uses session variable (current_setting) for test time control.
create function pgconductor.current_time ()
  returns timestamptz
  language plpgsql
  volatile
as $$
declare
  v_fake text;
begin
  v_fake := current_setting('pgconductor.fake_now', true);
  if v_fake is not null and length(trim(v_fake)) > 0 then
    return v_fake::timestamptz;
  end if;

  return clock_timestamp();
end;
$$;

-- utility function to generate a uuidv7 even for older postgres versions.
create function pgconductor.portable_uuidv7 ()
  returns uuid
  language plpgsql
  volatile
as $$
declare
  v_server_num integer := current_setting('server_version_num')::int;
  ts_ms bigint;
  b bytea;
  rnd bytea;
  i int;
begin
  if v_server_num >= 180000 then
    return uuidv7 ();
  end if;
  ts_ms := floor(extract(epoch from pgconductor.current_time()) * 1000)::bigint;
  rnd := uuid_send(public.uuid_generate_v4 ());
  b := repeat(E'\\000', 16)::bytea;
  for i in 0..5 loop
    b := set_byte(b, i, ((ts_ms >> ((5 - i) * 8)) & 255)::int);
  end loop;
  for i in 6..15 loop
    b := set_byte(b, i, get_byte(rnd, i));
  end loop;
  b := set_byte(b, 6, ((get_byte(b, 6) & 15) | (7 << 4)));
  b := set_byte(b, 8, ((get_byte(b, 8) & 63) | 128));
  return encode(b, 'hex')::uuid;
end;
$$;

CREATE TABLE pgconductor.settings (
    key text primary key,
    value jsonb not null
);

CREATE TABLE pgconductor.orchestrators (
    id uuid default pgconductor.portable_uuidv7() primary key,
    last_heartbeat_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version text,
    migration_number integer,
    shutdown_signal boolean default false not null
);

CREATE TABLE pgconductor.queues (
    name text primary key,
    completed_retention_days integer DEFAULT 7 NOT NULL,
    failed_retention_days integer DEFAULT 30 NOT NULL
);

CREATE TABLE pgconductor.executions (
    id uuid default pgconductor.portable_uuidv7(),
    task_key text not null,
    queue text not null default 'default',
    dedupe_key text,
    cron_expression text,
    created_at timestamptz default pgconductor.current_time() not null,
    failed_at timestamptz,
    completed_at timestamptz,
    payload jsonb default '{}'::jsonb not null,
    run_at timestamptz default pgconductor.current_time() not null,
    locked_at timestamptz,
    locked_by uuid,
    attempts integer default 0 not null,
    last_error text,
    priority integer default 0 not null,
    waiting_on_execution_id uuid,
    waiting_step_key text,
    primary key (id, queue),
    unique (task_key, dedupe_key, queue)
) PARTITION BY LIST (queue);

CREATE TABLE pgconductor.failed_executions (
    LIKE pgconductor.executions INCLUDING DEFAULTS INCLUDING GENERATED INCLUDING CONSTRAINTS EXCLUDING INDEXES,
    PRIMARY KEY (failed_at, id)
) PARTITION BY RANGE (failed_at);

CREATE TABLE pgconductor.completed_executions (
    LIKE pgconductor.executions INCLUDING DEFAULTS INCLUDING GENERATED INCLUDING CONSTRAINTS EXCLUDING INDEXES,
    PRIMARY KEY (completed_at, id)
) PARTITION BY RANGE (completed_at);

-- todo: this will be managed by pg_partman or a cron job in the future
CREATE TABLE pgconductor.failed_executions_default PARTITION OF pgconductor.failed_executions
    FOR VALUES FROM (MINVALUE) TO (MAXVALUE);

-- todo: this will be managed by pg_partman or a cron job in the future
CREATE TABLE pgconductor.completed_executions_default PARTITION OF pgconductor.completed_executions
    FOR VALUES FROM (MINVALUE) TO (MAXVALUE);

CREATE TABLE pgconductor.tasks (
    key text primary key,

    -- queue that this task belongs to (used for queue-based worker assignment)
    queue text default 'default' not null,

    -- retry settings - uses fixed Inngest-style backoff schedule
    max_attempts integer default 3 not null,

    -- task can be executed only within certain time windows
    -- e.g. business hours, weekends, nights, ...
    -- we will stop the execution of executions outside of these time windows at step boundaries
    window_start timetz,
    window_end timetz,
    CONSTRAINT "windows" CHECK (
        (window_start IS NULL AND window_end IS NULL) OR
        (
            window_start IS NOT NULL AND
            window_end IS NOT NULL AND
            window_start != window_end
        )
    )
);

CREATE TABLE pgconductor.steps (
    id uuid default pgconductor.portable_uuidv7() primary key,
    key text not null,
    execution_id uuid,
    result jsonb,
    created_at timestamptz default pgconductor.current_time() not null,
    unique (key, execution_id)
);

-- Load a step result by execution_id and key
CREATE OR REPLACE FUNCTION pgconductor.load_step(
    execution_id uuid,
    key text
) RETURNS jsonb
LANGUAGE sql
STABLE
SET search_path TO ''
AS $$
    SELECT jsonb_build_object('result', result) FROM pgconductor.steps
    WHERE execution_id = load_step.execution_id AND key = load_step.key;
$$;

-- Save a step result and optionally update execution run_at
CREATE OR REPLACE FUNCTION pgconductor.save_step(
    execution_id uuid,
    key text,
    result jsonb,
    run_in_ms integer default null
) RETURNS void
LANGUAGE sql
VOLATILE
SET search_path TO ''
AS $$
    WITH inserted AS (
        INSERT INTO pgconductor.steps (execution_id, key, result)
        VALUES (save_step.execution_id, save_step.key, save_step.result)
        ON CONFLICT (execution_id, key) DO NOTHING
        RETURNING id
    )
    UPDATE pgconductor.executions
    SET run_at = pgconductor.current_time() + (run_in_ms || ' milliseconds')::interval
    WHERE id = save_step.execution_id
      AND run_in_ms IS NOT NULL
      AND EXISTS (SELECT 1 FROM inserted);
$$;

-- TODO: use this table to manage concurrency, throttling and rate limiting
-- manage them when task is being updated/created
-- CREATE TABLE pgconductor.slots (
--     key text primary key,
--     task_key text not null,
--     locked_at timestamptz,
--     locked_by uuid
-- );

CREATE OR REPLACE FUNCTION pgconductor.orchestrators_heartbeat(
  orchestrator_id uuid,
  version text,
  migration_number integer
)
RETURNS boolean
LANGUAGE sql
VOLATILE
SET search_path TO ''
AS $function$
WITH latest AS (
  SELECT COALESCE(MAX(version), -1) AS db_version
  FROM pgconductor.schema_migrations
), upsert AS (
  INSERT INTO pgconductor.orchestrators AS o (
    id,
    version,
    migration_number,
    last_heartbeat_at
  )
  VALUES (
    orchestrators_heartbeat.orchestrator_id,
    orchestrators_heartbeat.version,
    orchestrators_heartbeat.migration_number,
    pgconductor.current_time()
  )
  ON CONFLICT (id)
  DO UPDATE
  SET
    last_heartbeat_at = pgconductor.current_time(),
    version = EXCLUDED.version,
    migration_number = EXCLUDED.migration_number
  RETURNING shutdown_signal
), marked AS (
  UPDATE pgconductor.orchestrators
  SET shutdown_signal = true
  WHERE id = orchestrators_heartbeat.orchestrator_id
    AND (SELECT db_version FROM latest) > orchestrators_heartbeat.migration_number
  RETURNING shutdown_signal
)
SELECT COALESCE(
  (SELECT shutdown_signal FROM marked),
  CASE
    WHEN (SELECT db_version FROM latest) > orchestrators_heartbeat.migration_number THEN true
    ELSE (SELECT shutdown_signal FROM upsert)
  END
);
$function$;

CREATE OR REPLACE FUNCTION pgconductor.sweep_orchestrators(migration_number int)
 RETURNS void
 LANGUAGE sql
 VOLATILE
 SET search_path TO ''
AS $function$
UPDATE pgconductor.orchestrators
SET shutdown_signal = true
WHERE migration_number < sweep_orchestrators.migration_number;
$function$;

CREATE OR REPLACE FUNCTION pgconductor.recover_stale_orchestrators(max_age interval)
 RETURNS void
 LANGUAGE sql
 VOLATILE
 SET search_path TO ''
AS $function$
WITH expired AS (
    DELETE FROM pgconductor.orchestrators o
    WHERE o.last_heartbeat_at < pgconductor.current_time() - recover_stale_orchestrators.max_age
    RETURNING o.id
)
UPDATE pgconductor.executions e
SET
  locked_by = NULL,
  locked_at = NULL
from expired
WHERE e.locked_by = expired.id
$function$
;

CREATE OR REPLACE FUNCTION pgconductor.orchestrator_shutdown(orchestrator_id uuid)
 RETURNS void
 LANGUAGE sql
 VOLATILE
 SET search_path TO ''
AS $function$
WITH deleted AS (
    DELETE FROM pgconductor.orchestrators
    WHERE id = orchestrator_shutdown.orchestrator_id
    RETURNING id
)
UPDATE pgconductor.executions e
SET
  locked_by = NULL,
  locked_at = NULL
FROM deleted
WHERE e.locked_by = deleted.id
$function$
;

-- Trigger function to manage executions partitions per queue
-- Automatically creates partition when queue is inserted
CREATE OR REPLACE FUNCTION pgconductor.manage_queue_partition()
 RETURNS trigger
 LANGUAGE plpgsql
 VOLATILE
 SET search_path TO ''
AS $function$
DECLARE
  v_partition_name text;
BEGIN
  IF TG_OP = 'INSERT' THEN
    v_partition_name := 'executions_' || replace(NEW.name, '-', '_');

    -- Create partition for this queue: executions_default, executions_reports, etc.
    EXECUTE format(
      'CREATE TABLE IF NOT EXISTS pgconductor.%I PARTITION OF pgconductor.executions FOR VALUES IN (%L) WITH (fillfactor=70)',
      v_partition_name,
      NEW.name
    );

    RETURN NEW;

  ELSIF TG_OP = 'UPDATE' THEN
    -- Disallow renaming queues
    IF NEW.name != OLD.name THEN
      RAISE EXCEPTION 'Renaming queues is not allowed. Queue name cannot be changed from % to %', OLD.name, NEW.name;
    END IF;

    RETURN NEW;

  ELSIF TG_OP = 'DELETE' THEN
    v_partition_name := 'executions_' || replace(OLD.name, '-', '_');

    -- Drop the partition for this queue
    EXECUTE format(
      'DROP TABLE IF EXISTS pgconductor.%I',
      v_partition_name
    );

    RETURN OLD;
  END IF;
END;
$function$;

-- Attach trigger to queues table
CREATE TRIGGER manage_queue_partition_trigger
  AFTER INSERT OR UPDATE OR DELETE ON pgconductor.queues
  FOR EACH ROW
  EXECUTE FUNCTION pgconductor.manage_queue_partition();

INSERT INTO pgconductor.queues (name) VALUES ('default');

-- SELECT partman.create_parent(
--     p_parent_table => 'pgconductor.failed_executions',
--     p_control => 'failed_at',
--     p_type => 'native',
--     p_interval => '1 day',
--     p_premake => 7,
--     p_start_partition => current_date::timestamptz,
--     p_inherit_fk => true
-- );

-- SELECT partman.create_parent(
--     p_parent_table => 'pgconductor.completed_executions',
--     p_control => 'completed_at',
--     p_type => 'native',
--     p_interval => '1 day',
--     p_premake => 7,
--     p_start_partition => current_date::timestamptz,
--     p_inherit_fk => true
-- );
--
-- UPDATE partman.part_config
-- SET
--     retention = '7 days',
--     retention_keep_table = false,
--     retention_keep_index = false
-- WHERE parent_table IN (
--     'pgconductor.failed_executions',
--     'pgconductor.completed_executions'
-- );

CREATE OR REPLACE FUNCTION pgconductor.get_executions(queue_name text, orchestrator_id uuid, batch_size integer default 100)
 RETURNS TABLE(id uuid, task_key text, payload jsonb, waiting_on_execution_id uuid, dedupe_key text, cron_expression text)
 LANGUAGE sql
 VOLATILE
 SET search_path TO ''
AS $function$
WITH queue_tasks AS (
  SELECT
    t.key,
    t.window_start,
    t.window_end,
    t.max_attempts
  FROM pgconductor.tasks t
  WHERE t.queue = get_executions.queue_name
),

-- Only proceed if we're inside the active window (or no window defined)
allowed AS (
  SELECT
    qt.key,
    qt.max_attempts
  FROM queue_tasks qt
  WHERE
    (qt.window_start IS NULL AND qt.window_end IS NULL)
    OR (
      pgconductor.current_time()::timetz >= qt.window_start
      AND pgconductor.current_time()::timetz < qt.window_end
    )
),

e AS (
  SELECT
    e.id,
    e.task_key
  FROM pgconductor.executions e
  JOIN allowed a ON e.task_key = a.key
  WHERE e.queue = get_executions.queue_name
    AND e.attempts < a.max_attempts
    AND e.locked_at IS NULL
    AND e.run_at <= pgconductor.current_time()
  ORDER BY e.priority ASC, e.run_at ASC
  LIMIT get_executions.batch_size
  FOR UPDATE SKIP LOCKED
)

UPDATE pgconductor.executions
SET
  attempts = executions.attempts + 1,
  locked_by = get_executions.orchestrator_id,
  locked_at = pgconductor.current_time()
FROM e
WHERE executions.id = e.id
RETURNING
  executions.id,
  executions.task_key,
  executions.payload,
  executions.waiting_on_execution_id,
  executions.dedupe_key,
  executions.cron_expression;
$function$
;

-- Composite type for returning execution results
create type pgconductor.execution_result as (
    execution_id uuid,
    status text, -- 'completed', 'failed', or 'released'
    result jsonb,
    error text
);

-- Fixed Inngest-style backoff schedule (in seconds)
-- Returns backoff delay for given attempt number (1-indexed)
-- 15s, 30s, 1m, 2m, 5m, 10m, 20m, 40m, 1h, 2h
-- Attempts beyond the schedule use the last value (2h)
CREATE OR REPLACE FUNCTION pgconductor.backoff_seconds(attempt integer)
 RETURNS integer
 LANGUAGE sql
 IMMUTABLE
AS $function$
  SELECT (ARRAY[15, 30, 60, 120, 300, 600, 1200, 2400, 3600, 7200])[LEAST(attempt, 10)];
$function$;

CREATE OR REPLACE FUNCTION pgconductor.return_executions(results pgconductor.execution_result[])
RETURNS integer
LANGUAGE sql
VOLATILE
SET search_path TO ''
AS $function$
  WITH results AS (
    SELECT *
    FROM unnest(return_executions.results) AS r
  ),
  -- move all completed executions to completed_executions
  completed AS (
    DELETE FROM pgconductor.executions e
    USING results r
    WHERE e.id = r.execution_id AND r.status = 'completed'
    RETURNING e.*
  ),
  inserted_completed AS (
    INSERT INTO pgconductor.completed_executions (
      id, task_key, dedupe_key, created_at, failed_at, completed_at,
      payload, run_at, locked_at, locked_by, attempts, last_error, priority
    )
    SELECT
      id,
      task_key,
      dedupe_key,
      created_at,
      failed_at,
      pgconductor.current_time(),
      payload,
      run_at,
      locked_at,
      locked_by,
      attempts,
      last_error,
      priority
    FROM completed
    RETURNING id
  ),
  -- complete executions that were waiting on completed children
  parent_steps_completed AS (
    INSERT INTO pgconductor.steps (execution_id, key, result)
    SELECT
      parent_e.id,
      parent_e.waiting_step_key,
      r.result
    FROM results r
    JOIN pgconductor.executions parent_e ON parent_e.waiting_on_execution_id = r.execution_id
    WHERE r.status = 'completed'
    ON CONFLICT (execution_id, key) DO NOTHING
    RETURNING execution_id
  ),
  woken_parents_completed AS (
    UPDATE pgconductor.executions
    SET
      run_at = pgconductor.current_time(),
      waiting_on_execution_id = NULL,
      waiting_step_key = NULL
    FROM parent_steps_completed
    WHERE id = parent_steps_completed.execution_id
    RETURNING id
  ),
  task AS (
    SELECT
      e.id AS execution_id,
      w.max_attempts
    FROM results r
    JOIN pgconductor.executions e ON e.id = r.execution_id
    JOIN pgconductor.tasks w ON w.key = e.task_key
    WHERE r.status = 'failed'
  ),
  permanently_failed_children AS (
    SELECT
      r.execution_id,
      r.error as child_error
    FROM results r
    JOIN pgconductor.executions e ON e.id = r.execution_id
    JOIN pgconductor.tasks w ON w.key = e.task_key
    WHERE r.status = 'failed' AND e.attempts >= w.max_attempts
  ),
  deleted_failed AS (
    DELETE FROM pgconductor.executions e
    WHERE (
      -- Direct failures: execution permanently failed
      e.id IN (SELECT execution_id FROM permanently_failed_children)
      OR
      -- CASCADE: parent waiting on permanently failed child
      e.waiting_on_execution_id IN (SELECT execution_id FROM permanently_failed_children)
    )
    RETURNING
      e.id,
      e.task_key,
      e.dedupe_key,
      e.created_at,
      e.payload,
      e.run_at,
      e.locked_at,
      e.locked_by,
      e.attempts,
      e.priority,
      COALESCE(
        (SELECT error FROM results WHERE execution_id = e.id AND status = 'failed'),
        (SELECT 'Child execution failed: ' || COALESCE(child_error, 'unknown error')
         FROM permanently_failed_children
         WHERE execution_id = e.waiting_on_execution_id)
      ) as last_error
  ),
  retried AS (
    UPDATE pgconductor.executions e
    SET
      last_error = COALESCE(
        (SELECT error FROM results WHERE execution_id = e.id AND status = 'failed'),
        'unknown error'
      ),
      run_at = GREATEST(pgconductor.current_time(), e.run_at)
        + (pgconductor.backoff_seconds(e.attempts) * INTERVAL '1 second'),
      locked_by = NULL,
      locked_at = NULL
    FROM task w
    WHERE e.id = w.execution_id
      AND e.attempts < w.max_attempts
    RETURNING e.*
  ),
  inserted_failed AS (
    INSERT INTO pgconductor.failed_executions (
      id, task_key, dedupe_key, created_at, failed_at, completed_at,
      payload, run_at, locked_at, locked_by, attempts, last_error, priority
    )
    SELECT
      id,
      task_key,
      dedupe_key,
      created_at,
      pgconductor.current_time(),
      NULL,
      payload,
      run_at,
      locked_at,
      locked_by,
      attempts,
      last_error,
      priority
    FROM deleted_failed
    RETURNING id
  ),
  released AS (
    UPDATE pgconductor.executions e
    SET
      attempts = GREATEST(e.attempts - 1, 0),
      locked_by = NULL,
      locked_at = NULL
    FROM results r
    WHERE e.id = r.execution_id
      AND r.status = 'released'
    RETURNING e.id
  )
  SELECT 1;
$function$;

create type pgconductor.execution_spec as (
    task_key text,
    payload jsonb,
    run_at timestamptz,
    dedupe_key text,
    cron_expression text,
    priority integer
);

create type pgconductor.task_spec as (
    key text,
    queue text,
    max_attempts integer,
    window_start timetz,
    window_end timetz
);

CREATE OR REPLACE FUNCTION pgconductor.register_worker(
    p_queue_name text,
    p_task_specs pgconductor.task_spec[],
    p_cron_schedules pgconductor.execution_spec[]
)
RETURNS void
LANGUAGE plpgsql
VOLATILE
SET search_path TO ''
AS $function$
BEGIN
  -- Step 1: Upsert queue (triggers partition creation)
  INSERT INTO pgconductor.queues (name)
  VALUES (p_queue_name)
  ON CONFLICT (name) DO NOTHING;

  -- Step 2: Register/update tasks
  INSERT INTO pgconductor.tasks (key, queue, max_attempts, window_start, window_end)
  SELECT
    spec.key,
    COALESCE(spec.queue, 'default'),
    COALESCE(spec.max_attempts, 3),
    spec.window_start,
    spec.window_end
  FROM unnest(p_task_specs) AS spec
  ON CONFLICT (key)
  DO UPDATE SET
    queue = COALESCE(EXCLUDED.queue, pgconductor.tasks.queue),
    max_attempts = COALESCE(EXCLUDED.max_attempts, pgconductor.tasks.max_attempts),
    window_start = EXCLUDED.window_start,
    window_end = EXCLUDED.window_end;

  -- Step 3: Insert scheduled cron executions (ON CONFLICT DO NOTHING)
  INSERT INTO pgconductor.executions (task_key, queue, payload, run_at, dedupe_key, cron_expression)
  SELECT
    spec.task_key,
    COALESCE(t.queue, 'default'),
    COALESCE(spec.payload, '{}'::jsonb),
    COALESCE(spec.run_at, pgconductor.current_time()),
    spec.dedupe_key,
    spec.cron_expression
  FROM unnest(p_cron_schedules) AS spec
  LEFT JOIN pgconductor.tasks t ON t.key = spec.task_key
  WHERE spec.dedupe_key IS NOT NULL
  ON CONFLICT (task_key, dedupe_key, queue) DO NOTHING;

  -- Step 4: Clean up stale schedules for this queue
  DELETE FROM pgconductor.executions
  WHERE queue = p_queue_name
    AND cron_expression IS NOT NULL
    AND run_at > pgconductor.current_time()
    AND (task_key, cron_expression) NOT IN (
      SELECT spec.task_key, spec.cron_expression
      FROM unnest(p_cron_schedules) AS spec
      WHERE spec.cron_expression IS NOT NULL
    );
END;
$function$;

CREATE OR REPLACE FUNCTION pgconductor.invoke(
    specs pgconductor.execution_spec[]
)
 RETURNS TABLE(id uuid)
 LANGUAGE plpgsql
 VOLATILE
 SET search_path TO ''
AS $function$
begin
  -- Clear keys that are currently locked so a subsequent insert can succeed.
  update pgconductor.executions as e
  set
    dedupe_key = null,
    attempts = w.max_attempts,
    locked_by = null,
    locked_at = null,
    last_error = 'superseded by reinvoke'
  from unnest(specs) spec
  join pgconductor.tasks w on w.key = spec.task_key
  where spec.dedupe_key is not null
  and e.dedupe_key = spec.dedupe_key
  and e.task_key = spec.task_key
  and e.locked_at is not null;

  return query insert into pgconductor.executions as e (
    id,
    task_key,
    queue,
    payload,
    run_at,
    dedupe_key,
    cron_expression,
    priority
  )
    select
      pgconductor.portable_uuidv7(),
      spec.task_key,
      COALESCE(t.queue, 'default'),
      coalesce(spec.payload, '{}'::jsonb),
      coalesce(spec.run_at, pgconductor.current_time()),
      spec.dedupe_key,
      spec.cron_expression,
      coalesce(spec.priority, 0)
    from unnest(specs) spec
    left join pgconductor.tasks t on t.key = spec.task_key
  returning e.id;
end;
$function$
;

CREATE OR REPLACE FUNCTION pgconductor.invoke(
    task_key text,
    payload jsonb default null,
    run_at timestamptz default null,
    dedupe_key text default null,
    cron_expression text default null,
    priority integer default null,
    parent_execution_id uuid default null,
    parent_step_key text default null,
    parent_timeout_ms integer default null
)
 RETURNS uuid
 LANGUAGE sql
 VOLATILE
 SET search_path TO ''
AS $function$
WITH inserted_child AS (
  INSERT INTO pgconductor.executions (
    id,
    task_key,
    queue,
    payload,
    run_at,
    cron_expression,
    dedupe_key,
    priority
  )
  SELECT
    pgconductor.portable_uuidv7(),
    invoke.task_key,
    COALESCE(t.queue, 'default'),
    COALESCE(invoke.payload, '{}'::jsonb),
    COALESCE(invoke.run_at, pgconductor.current_time()),
    invoke.cron_expression,
    invoke.dedupe_key,
    COALESCE(invoke.priority, 0)
  FROM (SELECT 1) AS dummy
  LEFT JOIN pgconductor.tasks t ON t.key = invoke.task_key
  RETURNING id
),
updated_parent AS (
  UPDATE pgconductor.executions
  SET
    waiting_on_execution_id = (SELECT id FROM inserted_child),
    waiting_step_key = invoke.parent_step_key,
    run_at = CASE
      WHEN invoke.parent_timeout_ms IS NOT NULL THEN
        pgconductor.current_time() + (invoke.parent_timeout_ms || ' milliseconds')::interval
      ELSE
        'infinity'::timestamptz
    END
  WHERE id = invoke.parent_execution_id
    AND invoke.parent_execution_id IS NOT NULL
  RETURNING 1
)
SELECT id FROM inserted_child;
$function$
;

CREATE OR REPLACE FUNCTION pgconductor.clear_waiting_state(
  execution_id uuid
)
RETURNS void
LANGUAGE sql
VOLATILE
SET search_path TO ''
AS $function$
  UPDATE pgconductor.executions
  SET
    waiting_on_execution_id = NULL,
    waiting_step_key = NULL
  WHERE id = clear_waiting_state.execution_id;
$function$
;
`,
});
