/* This file is auto-generated by `just build-migrations`; DO NOT EDIT */
export const getMigrations = (schemaName: string) => ({
  "0000000000_migrations.sql": String.raw`

create extension if not exists "uuid-ossp";

create schema if not exists pgconductor;

create table if not exists pgconductor.schema_migrations (
  version int primary key,
  name text not null,
  applied_at timestamp default now(),
  breaking boolean default false
);
`,
  "0000000001_setup.sql": String.raw`

-- Returns either the actual current timestamp or a fake one for tests.
-- Uses session variable (current_setting) for test time control.
create function pgconductor._private_current_time ()
  returns timestamptz
  language plpgsql
  volatile
as $$
declare
  v_fake text;
begin
  v_fake := current_setting('pgconductor.fake_now', true);
  if v_fake is not null and length(trim(v_fake)) > 0 then
    return v_fake::timestamptz;
  end if;

  return clock_timestamp();
end;
$$;

-- utility function to generate a uuidv7 even for older postgres versions.
create function pgconductor._private_portable_uuidv7 ()
  returns uuid
  language plpgsql
  volatile
as $$
declare
  v_server_num integer := current_setting('server_version_num')::int;
  ts_ms bigint;
  b bytea;
  rnd bytea;
  i int;
begin
  if v_server_num >= 180000 then
    return uuidv7 ();
  end if;
  ts_ms := floor(extract(epoch from pgconductor._private_current_time()) * 1000)::bigint;
  rnd := uuid_send(gen_random_uuid());
  b := repeat(E'\\000', 16)::bytea;
  for i in 0..5 loop
    b := set_byte(b, i, ((ts_ms >> ((5 - i) * 8)) & 255)::int);
  end loop;
  for i in 6..15 loop
    b := set_byte(b, i, get_byte(rnd, i));
  end loop;
  b := set_byte(b, 6, ((get_byte(b, 6) & 15) | (7 << 4)));
  b := set_byte(b, 8, ((get_byte(b, 8) & 63) | 128));
  return encode(b, 'hex')::uuid;
end;
$$;

create table pgconductor._private_orchestrators (
    id uuid default pgconductor._private_portable_uuidv7() primary key,
    last_heartbeat_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version text,
    migration_number integer
);

create index idx_orchestrators_heartbeat on pgconductor._private_orchestrators (last_heartbeat_at);
create index idx_orchestrators_sweep on pgconductor._private_orchestrators (migration_number);

create table pgconductor._private_orchestrator_signals (
    id uuid primary key default pgconductor._private_portable_uuidv7(),
    orchestrator_id uuid not null references pgconductor._private_orchestrators(id) on delete cascade,
    type text not null,
    execution_id uuid,
    payload jsonb not null default '{}'::jsonb,
    created_at timestamptz not null default pgconductor._private_current_time()
);

create index idx_orchestrator_signals_orchestrator on pgconductor._private_orchestrator_signals(orchestrator_id, created_at);

create unique index idx_orchestrator_signals_cancel_unique
    on pgconductor._private_orchestrator_signals(orchestrator_id, execution_id)
    where type = 'cancel_execution' and execution_id is not null;

create unique index idx_orchestrator_signals_shutdown_unique
    on pgconductor._private_orchestrator_signals(orchestrator_id)
    where type = 'shutdown';

create table pgconductor._private_queues (
    name text primary key
);

create table pgconductor._private_executions (
    id uuid default pgconductor._private_portable_uuidv7(),
    task_key text not null,
    queue text not null default 'default',
    dedupe_key text,
    cron_expression text,
    created_at timestamptz default pgconductor._private_current_time() not null,
    failed_at timestamptz,
    completed_at timestamptz,
    payload jsonb,
    run_at timestamptz default pgconductor._private_current_time() not null,
    locked_at timestamptz,
    locked_by uuid,
    is_available boolean generated always as (locked_at is null and failed_at is null and completed_at is null) stored not null,
    attempts integer default 0 not null,
    last_error text,
    cancelled boolean default false not null,
    priority integer default 0 not null,
    waiting_on_execution_id uuid,
    waiting_step_key text,
    parent_execution_id uuid,
    singleton_on timestamptz,
    trace_context jsonb,
    primary key (id, queue),
    unique (task_key, dedupe_key, queue)
) partition by list (queue);

-- unique index for singleton throttle/debounce enforcement on parent table
-- this automatically creates matching indexes on all partitions
-- must include partition key (queue) per PostgreSQL requirement
-- use coalesce to treat NULL dedupe_key as empty string for singleton matching
create unique index on pgconductor._private_executions (task_key, singleton_on, coalesce(dedupe_key, ''), queue)
where singleton_on is not null and completed_at is null and failed_at is null and cancelled = false;

create table pgconductor._private_tasks (
    key text primary key,

    -- queue that this task belongs to (used for queue-based worker assignment)
    queue text default 'default' not null,

    -- retry settings - uses fixed Inngest-style backoff schedule
    max_attempts integer default 3 not null,

    -- retention settings: NULL=keep forever, 0=delete immediately, N=delete after N days
    remove_on_complete_days integer,
    remove_on_fail_days integer,

    -- task can be executed only within certain time windows
    -- e.g. business hours, weekends, nights, ...
    -- we will stop the execution of executions outside of these time windows at step boundaries
    window_start timetz,
    window_end timetz,
    constraint "windows" check (
        (window_start is null and window_end is null) or
        (
            window_start is not null and
            window_end is not null and
            window_start != window_end
        )
    ),

    -- concurrency control: maximum number of concurrent executions across all workers
    -- NULL means no limit (unlimited concurrency)
    concurrency_limit integer
);

create table pgconductor._private_concurrency_slots (
    task_key text not null,
    slot_group_number integer not null,
    capacity integer not null,
    used integer default 0 not null,
    primary key (task_key, slot_group_number)
);

create index idx_slots_claim
    on pgconductor._private_concurrency_slots (task_key, capacity, used);

create table pgconductor._private_steps (
    id uuid default pgconductor._private_portable_uuidv7() primary key,
    key text not null,
    execution_id uuid not null,
    queue text not null,
    result jsonb,
    created_at timestamptz default pgconductor._private_current_time() not null,
    unique (key, execution_id),
    constraint fk_execution foreign key (execution_id, queue) references pgconductor._private_executions(id, queue) on delete cascade
);

create index idx_steps_execution_id on pgconductor._private_steps (execution_id);

-- Trigger function to manage executions partitions per queue
-- Automatically creates partition when queue is inserted
create or replace function pgconductor._private_manage_queue_partition()
 returns trigger
 language plpgsql
 volatile
 set search_path to ''
as $function$
declare
  v_partition_name text;
begin
  if tg_op = 'INSERT' then
    v_partition_name := 'executions_' || replace(new.name, '-', '_');

    -- Create partition for this queue: executions_default, executions_reports, etc.
    execute format(
      'create table if not exists pgconductor.%I partition of pgconductor._private_executions for values in (%L) with (fillfactor=70)',
      v_partition_name,
      new.name
    );

    -- create indices

    -- main index for fetching available executions
    execute format(
      'create index if not exists %I on pgconductor.%I (priority, run_at) include (id, task_key) where is_available = true',
      'idx_' || v_partition_name || '_get_executions',
      v_partition_name
    );

    -- index for waiting executions lookup
    execute format(
      'create index if not exists %I on pgconductor.%I (waiting_on_execution_id) where waiting_on_execution_id is not null',
      'idx_' || v_partition_name || '_waiting_on_execution_id',
      v_partition_name
    );

    -- index for parent execution lookup (child -> parent)
    execute format(
      'create index if not exists %I on pgconductor.%I (parent_execution_id) where parent_execution_id is not null',
      'idx_' || v_partition_name || '_parent_execution_id',
      v_partition_name
    );

    -- index for unlocking locked executions
    execute format(
      'create index if not exists %I on pgconductor.%I (locked_by) where locked_by is not null',
      'idx_' || v_partition_name || '_locked_by',
      v_partition_name
    );

    -- index for cleanup of completed
    execute format(
      'create index if not exists %I on pgconductor.%I (completed_at) where completed_at is not null',
      'idx_' || v_partition_name || '_completed_cleanup',
      v_partition_name
    );

    -- index for cleanup of failed
    execute format(
      'create index if not exists %I on pgconductor.%I (failed_at) where failed_at is not null',
      'idx_' || v_partition_name || '_failed_cleanup',
      v_partition_name
    );

    -- index for dynamic schedule lookups
    execute format(
      'create index if not exists %I on pgconductor.%I ((split_part(dedupe_key, ''::'', 2))) where dedupe_key like ''dynamic::%%'' and cron_expression is not null',
      'idx_' || v_partition_name || '_dynamic_schedule',
      v_partition_name
    );

    -- index for task_key joins (used in return_executions)
    execute format(
      'create index if not exists %I on pgconductor.%I (task_key)',
      'idx_' || v_partition_name || '_task_key',
      v_partition_name
    );

    RETURN NEW;

  elsif tg_op = 'UPDATE' then
    -- protect default queue from modification
    if old.name = 'default' or new.name = 'default' then
      raise exception 'Modifying the default queue is not allowed';
    end if;

    -- disallow renaming queues
    if new.name != old.name then
      raise exception 'Renaming queues is not allowed. Queue name cannot be changed from % to %', old.name, new.name;
    end if;

    return new;

  elsif tg_op = 'DELETE' then
    -- protect default queue from deletion
    if old.name = 'default' then
      raise exception 'Deleting the default queue is not allowed';
    end if;

    v_partition_name := 'executions_' || replace(old.name, '-', '_');

    -- drop the partition for this queue
    execute format(
      'drop table if exists pgconductor.%I',
      v_partition_name
    );

    return old;
  end if;
end;
$function$;

-- attach trigger to queues table
create trigger manage_queue_partition_trigger
  after insert or update or delete on pgconductor._private_queues
  for each row
  execute function pgconductor._private_manage_queue_partition();

-- create default queue (trigger will create executions_default partition)
insert into pgconductor._private_queues (name) values ('default');

-- drop a queue (will trigger partition deletion via trigger)
create or replace function pgconductor.drop_queue(queue_name text)
 returns void
 language sql
 volatile
 set search_path to ''
as $function$
  delete from pgconductor._private_queues where name = drop_queue.queue_name;
$function$;

create type pgconductor.execution_spec as (
    task_key text,
    queue text,
    payload jsonb,
    run_at timestamptz,
    dedupe_key text,
    dedupe_seconds integer,
    dedupe_next_slot boolean,
    cron_expression text,
    priority integer,
    trace_context jsonb
);

create type pgconductor.task_spec as (
    key text,
    queue text,
    max_attempts integer,
    remove_on_complete_days integer,
    remove_on_fail_days integer,
    window_start timetz,
    window_end timetz,
    concurrency_limit integer
);

create type pgconductor._private_event_operation as enum (
    'insert',
    'update',
    'delete'
);

create type pgconductor.event_subscription_spec as (
    task_key text,
    queue text,
    event_key text,
    schema_name text,
    table_name text,
    operation pgconductor._private_event_operation,
    when_clause text,
    payload_fields text[],
    column_names text[]
);

create or replace function pgconductor._private_register_worker(
    p_queue_name text,
    p_task_specs pgconductor.task_spec[],
    p_cron_schedules pgconductor.execution_spec[],
    p_event_subscriptions pgconductor.event_subscription_spec[] default array[]::pgconductor.event_subscription_spec[]
)
returns void
language plpgsql
volatile
set search_path to ''
as $function$
begin
  -- step 1: upsert queue (triggers partition creation)
  insert into pgconductor._private_queues (name)
  values (p_queue_name)
  on conflict (name) do nothing;

  -- step 2: register/update tasks
  insert into pgconductor._private_tasks (key, queue, max_attempts, remove_on_complete_days, remove_on_fail_days, window_start, window_end, concurrency_limit)
  select
    spec.key,
    coalesce(spec.queue, 'default'),
    coalesce(spec.max_attempts, 3),
    spec.remove_on_complete_days,
    spec.remove_on_fail_days,
    spec.window_start,
    spec.window_end,
    spec.concurrency_limit
  from unnest(p_task_specs) as spec
  on conflict (key)
  do update set
    queue = coalesce(excluded.queue, pgconductor._private_tasks.queue),
    max_attempts = coalesce(excluded.max_attempts, pgconductor._private_tasks.max_attempts),
    remove_on_complete_days = excluded.remove_on_complete_days,
    remove_on_fail_days = excluded.remove_on_fail_days,
    window_start = excluded.window_start,
    window_end = excluded.window_end,
    concurrency_limit = excluded.concurrency_limit;

  -- step 2a: manage concurrency slots
  -- create one row per slot (capacity=1 each)
  insert into pgconductor._private_concurrency_slots (task_key, slot_group_number, capacity, used)
  select
    spec.key,
    slot_num,
    1 as capacity,
    0 as used
  from unnest(p_task_specs) as spec
  cross join lateral generate_series(1, spec.concurrency_limit) as slot_num
  where spec.concurrency_limit is not null
  on conflict (task_key, slot_group_number)
  do update set
    capacity = excluded.capacity,
    used = least(pgconductor._private_concurrency_slots.used, excluded.capacity);

  -- clean up orphaned slots (tasks removed or concurrency_limit set to null)
  delete from pgconductor._private_concurrency_slots
  where task_key not in (
    select key from pgconductor._private_tasks
    where concurrency_limit is not null
  );

  -- clean up excess slots when concurrency decreased
  delete from pgconductor._private_concurrency_slots cs
  where cs.slot_group_number > (
    select concurrency_limit
    from pgconductor._private_tasks t
    where t.key = cs.task_key
  );

  -- step 3: insert scheduled cron executions (on conflict do nothing)
  insert into pgconductor._private_executions (task_key, queue, payload, run_at, dedupe_key, cron_expression)
  select
    spec.task_key,
    coalesce(spec.queue, 'default'),
    coalesce(spec.payload, '{}'::jsonb),
    coalesce(spec.run_at, pgconductor._private_current_time()),
    spec.dedupe_key,
    spec.cron_expression
  from unnest(p_cron_schedules) as spec
  where spec.dedupe_key is not null
  on conflict (task_key, dedupe_key, queue) do nothing;

  -- step 4: clean up stale schedules for this queue
  -- delete future executions for schedules that no longer exist
  delete from pgconductor._private_executions
  where queue = p_queue_name
    and cron_expression is not null
    and run_at > pgconductor._private_current_time()
    and dedupe_key like 'scheduled::%'
    and split_part(dedupe_key, '::', 2) not in (
      select split_part(spec.dedupe_key, '::', 2)
      from unnest(p_cron_schedules) as spec
      where spec.dedupe_key is not null and spec.dedupe_key like 'scheduled::%'
    );

  -- mark running executions as cancelled for schedules that no longer exist
  update pgconductor._private_executions
  set cancelled = true
  where queue = p_queue_name
    and cron_expression is not null
    and dedupe_key like 'scheduled::%'
    and locked_by is not null
    and completed_at is null
    and failed_at is null
    and cancelled = false
    and split_part(dedupe_key, '::', 2) not in (
      select split_part(spec.dedupe_key, '::', 2)
      from unnest(p_cron_schedules) as spec
      where spec.dedupe_key is not null and spec.dedupe_key like 'scheduled::%'
    );

  -- step 5: manage event subscriptions (only recreate triggers when subscriptions change)
  merge into pgconductor._private_event_subscriptions as target
  using (
    select
      s.task_key,
      s.queue,
      s.event_key,
      s.schema_name,
      s.table_name,
      s.operation,
      s.when_clause,
      s.payload_fields,
      s.column_names
    from unnest(p_event_subscriptions) as s
  ) as source
  on (
    target.queue = source.queue and
    target.task_key = source.task_key and
    coalesce(target.event_key, '') = coalesce(source.event_key, '') and
    coalesce(target.schema_name, '') = coalesce(source.schema_name, '') and
    coalesce(target.table_name, '') = coalesce(source.table_name, '') and
    coalesce(target.operation::text, '') = coalesce(source.operation::text, '') and
    coalesce(target.when_clause, '') = coalesce(source.when_clause, '') and
    coalesce(array_to_string(target.payload_fields, ','), '') =
      coalesce(array_to_string(source.payload_fields, ','), '') and
    coalesce(array_to_string(target.column_names, ','), '') =
      coalesce(array_to_string(source.column_names, ','), '')
  )
  when not matched then insert (
    task_key, queue, event_key, schema_name, table_name, operation,
    when_clause, payload_fields, column_names
  ) values (
    source.task_key, source.queue, source.event_key,
    source.schema_name, source.table_name, source.operation,
    source.when_clause, source.payload_fields, source.column_names
  );

  -- step 6: delete old subscriptions for this queue not in new set
  delete from pgconductor._private_event_subscriptions target
  where target.queue = p_queue_name
    and not exists (
      select 1 from unnest(p_event_subscriptions) source
      where target.task_key = source.task_key
        and coalesce(target.event_key, '') = coalesce(source.event_key, '')
        and coalesce(target.schema_name, '') = coalesce(source.schema_name, '')
        and coalesce(target.table_name, '') = coalesce(source.table_name, '')
        and coalesce(target.operation::text, '') = coalesce(source.operation::text, '')
        and coalesce(target.when_clause, '') = coalesce(source.when_clause, '')
        and coalesce(array_to_string(target.payload_fields, ','), '') =
          coalesce(array_to_string(source.payload_fields, ','), '')
        and coalesce(array_to_string(target.column_names, ','), '') =
          coalesce(array_to_string(source.column_names, ','), '')
    );
end;
$function$;

create or replace function pgconductor.invoke_batch(
    specs pgconductor.execution_spec[]
)
 returns table(id uuid)
 language plpgsql
 volatile
 set search_path to ''
as $function$
declare
    v_now timestamptz;
begin
    v_now := pgconductor._private_current_time();

    -- clear locked dedupe keys before batch insert
    update pgconductor._private_executions as e
    set
        dedupe_key = null,
        locked_by = null,
        locked_at = null,
        failed_at = v_now,
        last_error = 'superseded by reinvoke'
    from unnest(specs) as spec
    where e.dedupe_key = spec.dedupe_key
        and e.task_key = spec.task_key
        and e.queue = coalesce(spec.queue, 'default')
        and e.locked_at is not null
        and spec.dedupe_key is not null;

    -- batch insert all executions
    -- note: duplicate dedupe_keys within same batch will cause error
    -- users should deduplicate client-side if needed
    return query
    insert into pgconductor._private_executions (
        id,
        task_key,
        queue,
        payload,
        run_at,
        dedupe_key,
        singleton_on,
        cron_expression,
        priority,
        trace_context
    )
    select
        pgconductor._private_portable_uuidv7(),
        spec.task_key,
        coalesce(spec.queue, 'default'),
        spec.payload,
        coalesce(spec.run_at, v_now),
        spec.dedupe_key,
        case
            when spec.dedupe_seconds is not null then
                'epoch'::timestamptz + '1 second'::interval * (
                    spec.dedupe_seconds * floor(
                        extract(epoch from v_now) / spec.dedupe_seconds
                    )
                )
            else null
        end,
        spec.cron_expression,
        coalesce(spec.priority, 0),
        spec.trace_context
    from unnest(specs) as spec
    on conflict (task_key, dedupe_key, queue) do update set
        payload = excluded.payload,
        run_at = excluded.run_at,
        priority = excluded.priority,
        cron_expression = excluded.cron_expression,
        singleton_on = excluded.singleton_on,
        trace_context = excluded.trace_context
    returning pgconductor._private_executions.id;
end;
$function$
;

create or replace function pgconductor.invoke(
    p_task_key text,
    p_queue text default 'default',
    p_payload jsonb default null,
    p_run_at timestamptz default null,
    p_dedupe_key text default null,
    p_dedupe_seconds integer default null,
    p_dedupe_next_slot boolean default false,
    p_cron_expression text default null,
    p_priority integer default null,
    p_trace_context jsonb default null
)
 returns table(id uuid)
 language plpgsql
 volatile
 set search_path to ''
as $function$
declare
    v_now timestamptz;
    v_singleton_on timestamptz;
    v_next_singleton_on timestamptz;
    v_run_at timestamptz;
    v_new_id uuid;
begin
  v_now := pgconductor._private_current_time();
  v_run_at := coalesce(p_run_at, v_now);

  -- clear locked dedupe key before insert (supersede pattern)
  if p_dedupe_key is not null then
      update pgconductor._private_executions
      set
          dedupe_key = null,
          locked_by = null,
          locked_at = null,
          failed_at = v_now,
          last_error = 'superseded by reinvoke'
      where dedupe_key = p_dedupe_key
          and task_key = p_task_key
          and queue = p_queue
          and locked_at is not null;
  end if;

  -- singleton throttle/debounce logic
  if p_dedupe_seconds is not null then
      -- calculate current time slot (pg-boss formula)
      v_singleton_on := 'epoch'::timestamptz + '1 second'::interval * (
          p_dedupe_seconds * floor(
              extract(epoch from v_now) / p_dedupe_seconds
          )
      );

      if p_dedupe_next_slot = false then
          -- throttle: try current slot, return empty if blocked
          return query
          insert into pgconductor._private_executions (
              id,
              task_key,
              queue,
              payload,
              run_at,
              dedupe_key,
              singleton_on,
              cron_expression,
              priority,
              trace_context
          ) values (
              pgconductor._private_portable_uuidv7(),
              p_task_key,
              p_queue,
              p_payload,
              v_run_at,
              p_dedupe_key,
              v_singleton_on,
              p_cron_expression,
              coalesce(p_priority, 0),
              p_trace_context
          )
          on conflict (task_key, singleton_on, coalesce(dedupe_key, ''), queue)
          where singleton_on is not null and completed_at is null and failed_at is null and cancelled = false
          do nothing
          returning _private_executions.id;
          return;
      else
          -- debounce: upsert into next slot
          v_next_singleton_on := v_singleton_on + (p_dedupe_seconds || ' seconds')::interval;

          return query
          insert into pgconductor._private_executions (
              id,
              task_key,
              queue,
              payload,
              run_at,
              dedupe_key,
              singleton_on,
              cron_expression,
              priority,
              trace_context
          ) values (
              pgconductor._private_portable_uuidv7(),
              p_task_key,
              p_queue,
              p_payload,
              v_next_singleton_on,
              p_dedupe_key,
              v_next_singleton_on,
              p_cron_expression,
              coalesce(p_priority, 0),
              p_trace_context
          )
          on conflict (task_key, singleton_on, coalesce(dedupe_key, ''), queue)
          where singleton_on is not null and completed_at is null and failed_at is null and cancelled = false
          do update set
              payload = excluded.payload,
              run_at = excluded.run_at,
              priority = excluded.priority,
              trace_context = excluded.trace_context
          returning _private_executions.id;
          return;
      end if;
  end if;

  -- regular invoke (no singleton)
  if p_dedupe_key is not null then
      -- clear keys that are currently locked so a subsequent insert can succeed.
      update pgconductor._private_executions as e
      set
        dedupe_key = null,
        locked_by = null,
        locked_at = null,
        failed_at = pgconductor._private_current_time(),
        last_error = 'superseded by reinvoke'
      where e.dedupe_key = p_dedupe_key
        and e.task_key = p_task_key
        and e.queue = p_queue
        and e.locked_at is not null;
  end if;

  return query insert into pgconductor._private_executions as e (
    id,
    task_key,
    queue,
    payload,
    run_at,
    dedupe_key,
    cron_expression,
    priority,
    trace_context
  ) values (
    pgconductor._private_portable_uuidv7(),
    p_task_key,
    p_queue,
    p_payload,
    v_run_at,
    p_dedupe_key,
    p_cron_expression,
    coalesce(p_priority, 0),
    p_trace_context
  )
  on conflict (task_key, dedupe_key, queue) do update set
    payload = excluded.payload,
    run_at = excluded.run_at,
    priority = excluded.priority,
    cron_expression = excluded.cron_expression,
    trace_context = excluded.trace_context
  returning e.id;
end;
$function$
;

-- cancel an execution
create or replace function pgconductor.cancel_execution(
  p_execution_id uuid,
  p_reason text default 'Cancelled by user'
)
returns boolean
language plpgsql
volatile
set search_path to ''
as $function$
declare
  v_orchestrator_id uuid;
  v_queue text;
  v_completed boolean;
  v_failed boolean;
  v_rows_affected integer;
begin
  select
    locked_by,
    queue,
    completed_at is not null,
    failed_at is not null
  into v_orchestrator_id, v_queue, v_completed, v_failed
  from pgconductor._private_executions
  where id = p_execution_id;

  if not found or v_completed or v_failed then
    return false;
  end if;

  if v_orchestrator_id is null then
    -- pending: fail immediately
    update pgconductor._private_executions
    set
      failed_at = pgconductor._private_current_time(),
      last_error = p_reason,
      locked_by = null,
      locked_at = null
    where id = p_execution_id
      and completed_at is null
      and failed_at is null;

    get diagnostics v_rows_affected = row_count;
    return v_rows_affected > 0;
  else
    -- running: signal orchestrator + set cancelled flag
    update pgconductor._private_executions
    set
      cancelled = true,
      last_error = p_reason
    where id = p_execution_id
      and completed_at is null
      and cancelled = false;

    get diagnostics v_rows_affected = row_count;

    if v_rows_affected > 0 then
      insert into pgconductor._private_orchestrator_signals
        (orchestrator_id, type, execution_id, payload)
      values (
        v_orchestrator_id,
        'cancel_execution',
        p_execution_id,
        jsonb_build_object('queue', v_queue, 'reason', p_reason)
      )
      on conflict (orchestrator_id, execution_id)
        where type = 'cancel_execution' and execution_id is not null
      do nothing;

      return true;
    else
      return false;
    end if;
  end if;
end;
$function$;

`,
  "0000000002_events.sql": String.raw`
alter table pgconductor._private_executions
    add column if not exists subscription_id uuid;

create table if not exists pgconductor._private_custom_events (
    id uuid default pgconductor._private_portable_uuidv7() not null,
    event_key text not null,
    payload jsonb not null default '{}'::jsonb,
    created_at timestamptz default pgconductor._private_current_time() not null,
    primary key (created_at, id)
) partition by range (created_at);

create index if not exists idx_custom_events_event_key
    on pgconductor._private_custom_events (event_key, created_at desc);

-- Create initial partition for custom events (will cover many years)
create table if not exists pgconductor._private_custom_events_default
    partition of pgconductor._private_custom_events
    for values from (minvalue) to (maxvalue);

create table if not exists pgconductor._private_event_subscriptions (
    id uuid primary key default pgconductor._private_portable_uuidv7(),

    task_key text not null,
    queue text not null,

    event_key text,
    schema_name text,
    table_name text,
    operation pgconductor._private_event_operation,

    when_clause text,
    payload_fields text[],
    column_names text[],

    created_at timestamptz not null default pgconductor._private_current_time(),

    constraint chk_event_type check (
        (event_key is not null and schema_name is null and table_name is null and operation is null)
        or
        (event_key is null and schema_name is not null and table_name is not null and operation is not null)
    )
);

create index if not exists idx_event_subscriptions_custom
    on pgconductor._private_event_subscriptions (event_key)
    where event_key is not null;

create index if not exists idx_event_subscriptions_database
    on pgconductor._private_event_subscriptions (schema_name, table_name, operation)
    where schema_name is not null;

create or replace function pgconductor._private_sync_custom_event_trigger()
    returns trigger
    language plpgsql
    security definer
    set search_path to ''
as $_$
declare
    v_invoke_blocks text;
    v_has_subscriptions boolean;
begin
    -- Only process custom event subscriptions (event_key is not null)
    if coalesce(new.event_key, old.event_key) is null then
        return coalesce(new, old);
    end if;

    drop trigger if exists pgconductor_custom_event on pgconductor._private_custom_events;
    drop function if exists pgconductor._private_trigger_custom_event;

    select exists(
        select 1
        from pgconductor._private_event_subscriptions
        where event_key is not null
    ) into v_has_subscriptions;

    if v_has_subscriptions then
        v_invoke_blocks := (
            select string_agg(format(
                $sql$
                if new.event_key = %L and (%s) then
                    v_task_keys := array_append(v_task_keys, %L);
                    v_queues := array_append(v_queues, %L);
                    v_payloads := array_append(v_payloads, jsonb_build_object('event', new.event_key, 'payload', %s));
                    v_subscription_ids := array_append(v_subscription_ids, %L);
                end if;
                $sql$,
                sub.event_key,
                coalesce(nullif(sub.when_clause, ''), 'true'),
                sub.task_key,
                t.queue,
                pgconductor._private_build_payload_fields(sub.payload_fields, 'new.payload'),
                sub.id
            ), e'\n')
            from pgconductor._private_event_subscriptions as sub
            join pgconductor._private_tasks as t on t.key = sub.task_key
            where sub.event_key is not null
        );

        execute format(
            $sql$
            create or replace function pgconductor._private_trigger_custom_event()
                returns trigger
                language plpgsql
                security definer
                set search_path to ''
            as $inner$
            declare
                v_task_keys text[];
                v_queues text[];
                v_payloads jsonb[];
                v_subscription_ids uuid[];
            begin
                %s

                if array_length(v_task_keys, 1) > 0 then
                    insert into pgconductor._private_executions (task_key, queue, payload, subscription_id)
                    select unnest(v_task_keys), unnest(v_queues), unnest(v_payloads), unnest(v_subscription_ids);
                end if;

                return new;
            end
            $inner$
            $sql$,
            v_invoke_blocks
        );

        execute $sql$
            create trigger pgconductor_custom_event
                after insert on pgconductor._private_custom_events
                for each row
                execute function pgconductor._private_trigger_custom_event()
        $sql$;
    end if;

    if tg_op = 'DELETE' then
        return old;
    end if;

    return new;
end;
$_$;

create trigger sync_custom_event_trigger
    after insert or delete or update on pgconductor._private_event_subscriptions
    for each row
    execute function pgconductor._private_sync_custom_event_trigger();

create or replace function pgconductor._private_build_payload_fields(
    p_payload_fields text[],
    p_payload_expr text
)
    returns text
    language sql
    immutable
    set search_path to ''
as $_$
    select case
        when p_payload_fields is null then p_payload_expr
        else 'jsonb_build_object(' || array_to_string(
            array(
                select format('%L, %s->%L', field, p_payload_expr, field)
                from unnest(p_payload_fields) as field
            ),
            ', '
        ) || ')'
    end;
$_$;

create or replace function pgconductor._private_build_column_list(
    p_column_names text[],
    p_record_name text
)
    returns text
    language sql
    immutable
    set search_path to ''
as $_$
    select case
        when p_column_names is null then format('row_to_json(%I.*)', p_record_name)
        else 'jsonb_build_object(' || array_to_string(
            array(
                select format('%L, %I.%I', col, p_record_name, col)
                from unnest(p_column_names) as col
            ),
            ', '
        ) || ')'
    end;
$_$;

create or replace function pgconductor._private_sync_database_trigger()
    returns trigger
    language plpgsql
    security definer
    set search_path to ''
as $_$
declare
    v_table_name text := coalesce(new.table_name, old.table_name);
    v_schema_name text := coalesce(new.schema_name, old.schema_name);
    v_op pgconductor._private_event_operation;
    v_invoke_blocks text;
    v_has_subscriptions boolean;
begin
    -- Only process database event subscriptions (schema_name is not null)
    if v_schema_name is null then
        return coalesce(new, old);
    end if;

    -- Process each operation type (insert, update, delete)
    foreach v_op in array array['insert', 'update', 'delete']::pgconductor._private_event_operation[] loop
        -- Drop existing trigger and function
        execute format(
            'drop trigger if exists pgconductor_event_%s on %I.%I',
            v_op::text, v_schema_name, v_table_name
        );

        execute format(
            'drop function if exists pgconductor._private_trigger_event_%s_on_%I_%I',
            v_op::text, v_schema_name, v_table_name
        );

        -- Check if there are any subscriptions for this operation
        select exists(
            select 1
            from pgconductor._private_event_subscriptions
            where table_name = v_table_name
                and schema_name = v_schema_name
                and operation = v_op
        ) into v_has_subscriptions;

        if v_has_subscriptions then
            -- Build if blocks to check conditions and append to arrays
            -- Each subscription's when_clause is evaluated inside the trigger function
            v_invoke_blocks := (
                select string_agg(format(
                    $sql$
                    if %s then
                        v_task_keys := array_append(v_task_keys, %L);
                        v_queues := array_append(v_queues, %L);
                        v_payloads := array_append(v_payloads, jsonb_build_object(
                            'event', %L,
                            'payload', jsonb_build_object(
                                'old', case when tg_op is distinct from 'INSERT' then %s else null end,
                                'new', case when tg_op is distinct from 'DELETE' then %s else null end,
                                'tg_table', tg_table_name,
                                'tg_op', tg_op
                            )
                        ));
                        v_subscription_ids := array_append(v_subscription_ids, %L);
                    end if;
                    $sql$,
                    coalesce(nullif(sub.when_clause, ''), 'true'),
                    sub.task_key,
                    t.queue,
                    format('%s.%s.%s', v_schema_name, v_table_name, v_op::text),
                    pgconductor._private_build_column_list(sub.column_names, 'old'),
                    pgconductor._private_build_column_list(sub.column_names, 'new'),
                    sub.id
                ), e'\n')
                from pgconductor._private_event_subscriptions as sub
                join pgconductor._private_tasks as t on t.key = sub.task_key
                where sub.table_name = v_table_name
                    and sub.schema_name = v_schema_name
                    and sub.operation = v_op
            );

            -- Create trigger function
            execute format(
                $sql$
                create or replace function pgconductor._private_trigger_event_%s_on_%I_%I()
                    returns trigger
                    language plpgsql
                    security definer
                    set search_path to ''
                as $inner$
                declare
                    v_task_keys text[];
                    v_queues text[];
                    v_payloads jsonb[];
                    v_subscription_ids uuid[];
                begin
                    %s

                    if array_length(v_task_keys, 1) > 0 then
                        insert into pgconductor._private_executions (task_key, queue, payload, subscription_id)
                        select unnest(v_task_keys), unnest(v_queues), unnest(v_payloads), unnest(v_subscription_ids);
                    end if;

                    if tg_op = 'DELETE' then
                        return old;
                    end if;

                    return new;
                end
                $inner$
                $sql$,
                v_op::text,
                v_schema_name,
                v_table_name,
                v_invoke_blocks
            );

            -- Create trigger
            execute format(
                $sql$
                create trigger pgconductor_event_%s
                    after %s on %I.%I
                    for each row
                    execute function pgconductor._private_trigger_event_%s_on_%I_%I()
                $sql$,
                v_op::text,
                upper(v_op::text),
                v_schema_name,
                v_table_name,
                v_op::text,
                v_schema_name,
                v_table_name
            );
        end if;
    end loop;

    if tg_op = 'DELETE' then
        return old;
    end if;

    return new;
end;
$_$;

create trigger sync_database_trigger
    after insert or delete or update on pgconductor._private_event_subscriptions
    for each row
    execute function pgconductor._private_sync_database_trigger();

create or replace function pgconductor.emit_event(
    p_event_key text,
    p_payload jsonb default '{}'::jsonb
)
    returns uuid
    language sql
    volatile
    set search_path to ''
as $_$
    insert into pgconductor._private_custom_events (event_key, payload)
    values (p_event_key, p_payload)
    returning id;
$_$;
`,
  "0000000003_trace_context.sql": String.raw`
-- Add trace_context column for OpenTelemetry context propagation
-- This stores W3C traceparent/tracestate for distributed tracing

-- Add column to executions table
alter table pgconductor._private_executions
add column if not exists trace_context jsonb;

-- Add trace_context to execution_spec type (if not already present)
do $$
begin
  alter type pgconductor.execution_spec add attribute trace_context jsonb;
exception
  when duplicate_column then null;
end $$;

-- Drop old invoke function to avoid ambiguity (different param count)
drop function if exists pgconductor.invoke(text, text, jsonb, timestamp with time zone, text, integer, boolean, text, integer);

-- Update invoke_batch function to pass trace_context through
-- Preserves all existing logic, just adds trace_context column
create or replace function pgconductor.invoke_batch(
    specs pgconductor.execution_spec[]
)
 returns table(id uuid)
 language plpgsql
 volatile
 set search_path to ''
as $function$
declare
    v_now timestamptz;
begin
    v_now := pgconductor._private_current_time();

    -- clear locked dedupe keys before batch insert
    update pgconductor._private_executions as e
    set
        dedupe_key = null,
        locked_by = null,
        locked_at = null,
        failed_at = v_now,
        last_error = 'superseded by reinvoke'
    from unnest(specs) as spec
    where e.dedupe_key = spec.dedupe_key
        and e.task_key = spec.task_key
        and e.queue = coalesce(spec.queue, 'default')
        and e.locked_at is not null
        and spec.dedupe_key is not null;

    -- batch insert all executions
    -- note: duplicate dedupe_keys within same batch will cause error
    -- users should deduplicate client-side if needed
    return query
    insert into pgconductor._private_executions (
        id,
        task_key,
        queue,
        payload,
        run_at,
        dedupe_key,
        singleton_on,
        cron_expression,
        priority,
        trace_context
    )
    select
        pgconductor._private_portable_uuidv7(),
        spec.task_key,
        coalesce(spec.queue, 'default'),
        spec.payload,
        coalesce(spec.run_at, v_now),
        spec.dedupe_key,
        case
            when spec.dedupe_seconds is not null then
                'epoch'::timestamptz + '1 second'::interval * (
                    spec.dedupe_seconds * floor(
                        extract(epoch from v_now) / spec.dedupe_seconds
                    )
                )
            else null
        end,
        spec.cron_expression,
        coalesce(spec.priority, 0),
        spec.trace_context
    from unnest(specs) as spec
    on conflict (task_key, dedupe_key, queue) do update set
        payload = excluded.payload,
        run_at = excluded.run_at,
        priority = excluded.priority,
        cron_expression = excluded.cron_expression,
        singleton_on = excluded.singleton_on,
        trace_context = excluded.trace_context
    returning pgconductor._private_executions.id;
end;
$function$
;

-- Update invoke function to pass trace_context through
-- Preserves all existing logic, just adds trace_context parameter and column
create or replace function pgconductor.invoke(
    p_task_key text,
    p_queue text default 'default',
    p_payload jsonb default null,
    p_run_at timestamptz default null,
    p_dedupe_key text default null,
    p_dedupe_seconds integer default null,
    p_dedupe_next_slot boolean default false,
    p_cron_expression text default null,
    p_priority integer default null,
    p_trace_context jsonb default null
)
 returns table(id uuid)
 language plpgsql
 volatile
 set search_path to ''
as $function$
declare
    v_now timestamptz;
    v_singleton_on timestamptz;
    v_next_singleton_on timestamptz;
    v_run_at timestamptz;
    v_new_id uuid;
begin
  v_now := pgconductor._private_current_time();
  v_run_at := coalesce(p_run_at, v_now);

  -- clear locked dedupe key before insert (supersede pattern)
  if p_dedupe_key is not null then
      update pgconductor._private_executions
      set
          dedupe_key = null,
          locked_by = null,
          locked_at = null,
          failed_at = v_now,
          last_error = 'superseded by reinvoke'
      where dedupe_key = p_dedupe_key
          and task_key = p_task_key
          and queue = p_queue
          and locked_at is not null;
  end if;

  -- singleton throttle/debounce logic
  if p_dedupe_seconds is not null then
      -- calculate current time slot (pg-boss formula)
      v_singleton_on := 'epoch'::timestamptz + '1 second'::interval * (
          p_dedupe_seconds * floor(
              extract(epoch from v_now) / p_dedupe_seconds
          )
      );

      if p_dedupe_next_slot = false then
          -- throttle: try current slot, return empty if blocked
          return query
          insert into pgconductor._private_executions (
              id,
              task_key,
              queue,
              payload,
              run_at,
              dedupe_key,
              singleton_on,
              cron_expression,
              priority,
              trace_context
          ) values (
              pgconductor._private_portable_uuidv7(),
              p_task_key,
              p_queue,
              p_payload,
              v_run_at,
              p_dedupe_key,
              v_singleton_on,
              p_cron_expression,
              coalesce(p_priority, 0),
              p_trace_context
          )
          on conflict (task_key, singleton_on, coalesce(dedupe_key, ''), queue)
          where singleton_on is not null and completed_at is null and failed_at is null and cancelled = false
          do nothing
          returning _private_executions.id;
          return;
      else
          -- debounce: upsert into next slot
          v_next_singleton_on := v_singleton_on + (p_dedupe_seconds || ' seconds')::interval;

          return query
          insert into pgconductor._private_executions (
              id,
              task_key,
              queue,
              payload,
              run_at,
              dedupe_key,
              singleton_on,
              cron_expression,
              priority,
              trace_context
          ) values (
              pgconductor._private_portable_uuidv7(),
              p_task_key,
              p_queue,
              p_payload,
              v_next_singleton_on,
              p_dedupe_key,
              v_next_singleton_on,
              p_cron_expression,
              coalesce(p_priority, 0),
              p_trace_context
          )
          on conflict (task_key, singleton_on, coalesce(dedupe_key, ''), queue)
          where singleton_on is not null and completed_at is null and failed_at is null and cancelled = false
          do update set
              payload = excluded.payload,
              run_at = excluded.run_at,
              priority = excluded.priority,
              trace_context = excluded.trace_context
          returning _private_executions.id;
          return;
      end if;
  end if;

  -- regular invoke (no singleton)
  if p_dedupe_key is not null then
      -- clear keys that are currently locked so a subsequent insert can succeed.
      update pgconductor._private_executions as e
      set
        dedupe_key = null,
        locked_by = null,
        locked_at = null,
        failed_at = pgconductor._private_current_time(),
        last_error = 'superseded by reinvoke'
      where e.dedupe_key = p_dedupe_key
        and e.task_key = p_task_key
        and e.queue = p_queue
        and e.locked_at is not null;
  end if;

  return query insert into pgconductor._private_executions as e (
    id,
    task_key,
    queue,
    payload,
    run_at,
    dedupe_key,
    cron_expression,
    priority,
    trace_context
  ) values (
    pgconductor._private_portable_uuidv7(),
    p_task_key,
    p_queue,
    p_payload,
    v_run_at,
    p_dedupe_key,
    p_cron_expression,
    coalesce(p_priority, 0),
    p_trace_context
  )
  on conflict (task_key, dedupe_key, queue) do update set
    payload = excluded.payload,
    run_at = excluded.run_at,
    priority = excluded.priority,
    cron_expression = excluded.cron_expression,
    trace_context = excluded.trace_context
  returning e.id;
end;
$function$
;
`,
});
