# Review

## Reliability snapshot

- `packages/pgconductor-js/src/database-client.ts:73-365` centralises all SQL access behind a pooled `postgres` instance plus an infinite retry loop. The helper now understands both SQLSTATEs and Postgres.js-specific connection errors (`CONNECTION_CLOSED`, `CONNECTION_DESTROYED`, `CONNECT_TIMEOUT`), so transient outages no longer bubble past the DAL.
- Every high-level operation (heartbeats, migrations, worker fetch/flush, invocations) goes through that helper with descriptive labels, ensuring uniform logging and automatic driver reuse whenever sockets drop.
- The conductor owns the shared `DatabaseClient` (`packages/pgconductor-js/src/conductor.ts:1-68`), and orchestrators now reuse it (`packages/pgconductor-js/src/orchestrator.ts:36-75`), so multiple orchestrators/tasks can share the same connection pool without bespoke teardown logic.

## Risks & potentially dangerous behaviors

1. **Side effects can run twice after transport errors** – The retry loop in `packages/pgconductor-js/src/database-client.ts:106-138` blindly re-executes the supplied closure. If a stored procedure completed on the server but the TCP connection died before the client received the acknowledgement, we will call it again. Operations such as `returnExecutions` (`packages/pgconductor-js/src/database-client.ts:335-364`) and `invoke`/`invokeBatch` (`packages/pgconductor-js/src/database-client.ts:371-409`) need to be idempotent or guard via unique keys, otherwise a single outage can duplicate completions or enqueue jobs twice.
2. **Flush buffer can grow without bound on permanent errors** – When `return_executions` rejects for a non-retryable reason (bad payload, serialization bug), the worker simply logs and re-adds the batch (`packages/pgconductor-js/src/worker.ts:170-221`). Because `DatabaseClient` now throws immediately for non-transient errors, this code will spin forever, retaining the same batch in memory and preventing future completions from being persisted.
3. **Migration coordination still lacks a backoff escape hatch** – `SchemaManager.ensureLatest()` loops indefinitely as long as `applyMigration` returns "busy" (`packages/pgconductor-js/src/schema-manager.ts:36-75`). If the lock holder wedges (for example due to a coding error rather than a transient DB issue), new orchestrators never shut down nor escalate, so deployments can deadlock. A maximum wait or abort hook tied to the orchestrator signal would make this path safer.
4. **Retry logging can spam operators during long outages** – Every retry emits `console.warn` (`packages/pgconductor-js/src/database-client.ts:120-128`). During a prolonged outage this results in one log line per attempt per operation with no throttling, which can drown out other diagnostics. Consider either aggregating the warnings or gating them behind a logger interface.
5. **Retrying TLS/DNS errors can mask misconfiguration** – We now classify DNS and TLS negotiation failures (`ENOTFOUND`, `EAI_AGAIN`, `ERR_TLS_*`, etc.) as retryable (`packages/pgconductor-js/src/database-client.ts:29-64`). While this keeps us waiting through transient outages, it also means operator mistakes (bad cert, wrong hostname) lead to infinite retries with no escalation. Consider surfacing a warning after N attempts or exposing a hook so these conditions can alert humans.

Addressing the items above would close the remaining reliability gaps now that the core client is resilient to most of the Postgres.js error surface.
