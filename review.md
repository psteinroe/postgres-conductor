# Review

## Findings
1. **High – migrations fail because functions reference columns that do not exist**  
   The core SQL (`migrations/0000000001_setup.sql:561-629`) updates `pgconductor.executions` columns named `max_attempts`, `updated_at`, and `is_available`, yet the table definition at lines 262-276 does not expose any of them. `return_executions` also expects `e.max_attempts` (line 595) and writes `completed_at` for rows that never had that column populated. Running the migration therefore errors during function compilation, preventing any install and leaving the orchestrator unusable.  
2. **High – `pgconductor.get_executions` CTE omits `max_attempts` but the filter uses it**  
   In the same SQL file, the `task` CTE (lines 377-395) selects only window and visibility_timeout fields, yet the later filter applies `e.attempts < t.max_attempts` (lines 397-420). Postgres raises “column max_attempts does not exist” at creation time, so the orchestrator can never fetch work even if the broader migration succeeds.  
3. **High – orchestrators delay registration until the first heartbeat**  
   `Orchestrator.start()` spins up workers immediately after scheduling (but not awaiting) the first heartbeat timer (packages/pgconductor-js/src/Orchestrator.ts:103-198). Because the only code path that inserts into `pgconductor.orchestrators` is the heartbeat function defined in `migrations/0000000001_setup.sql:61-90`, a crash in the initial 30 s window leaves any locked executions orphaned forever—`recover_stale_orchestrators` and `orchestrator_shutdown` only clean up IDs that exist in that table (SQL lines 92-142). **Proposed fix:** perform a synchronous registration step before workers start (e.g., call a dedicated `registerOrchestrator` RPC or invoke the heartbeat once inline, retrying on transient errors) and keep the first timer solely for periodic updates. That ensures stale-lock recovery always has an ID to target even if the process dies immediately after startup.  
4. **High – migration coordination can hang forever under lock contention**  
   When another process holds the advisory lock, `SchemaManager.ensureLatest()` drops into an infinite `while (true)` polling loop (packages/pgconductor-js/src/SchemaManager.ts:96-116). If the lock holder dies before committing migrations, the version never advances and this spinner blocks startup permanently. There’s also no timeout or abort signal hook, so rolling deployments can deadlock the cluster. The `shouldShutdown` flag the orchestrator checks (Orchestrator.ts:86-101) is never returned, so even intentional backoff cannot trigger a graceful shutdown. **Proposed fix:** replace the busy loop with a bounded wait that honours an abort signal—after N retries or a max duration, release control by returning `{shouldShutdown: true}` so the orchestrator can exit cleanly. Additionally, periodically re-try `pg_try_advisory_lock` with exponential backoff, and if the owning session disappears (no heartbeat progress for > stale threshold), force cleanup rather than waiting forever.  
5. **Medium – initial schema detection masks real database failures**  
   `getInstalledVersion()` swallows every error and reports `-1` (SchemaManager.ts:30-50). Permission issues, syntax errors, or missing extensions therefore masquerade as “fresh install,” leading the orchestrator to rerun migrations that will immediately fail again and obscuring the real cause. At minimum, non-`42P01` (relation missing) errors should be rethrown so operators can act.  
6. **Medium – migrations never mark other orchestrators for shutdown on breaking changes**  
   The schema logic only checks `migrationsToApply.some((m) => m.breaking)` (SchemaManager.ts:128-153), but the SQL format does not provide any `--!breaking` annotations (migrations/0000000001_setup.sql). Because `MigrationStore` derives the `breaking` flag from those annotations (packages/pgconductor-js/src/MigrationStore.ts:23-33), all migrations currently count as non-breaking and no shutdown signal is ever sent, even during incompatible DDL. This risks mixing schema versions across workers.  
7. **Low – `portable_uuidv7` references a nonexistent schema**  
   The helper uses `absurd.current_time()` (migrations/0000000001_setup.sql:340-369), but no `absurd` schema exists in the install script. The routine raises `schema "absurd" does not exist`, again blocking migrations until the typo is fixed.  

## Questions / Follow-ups
- I couldn’t find any `SchemaStore` implementation in the client package—should the orchestrator rely solely on `MigrationStore`, or is a different component expected?  
- The SQL in `migrations/` seems to be the intended source of truth; can we remove the outdated generated snapshot under `src/generated/` to avoid diverging definitions during future reviews?

## Fixes Implemented
- `migrations/0000000001_setup.sql`: marked as breaking, corrected `pgconductor.get_executions` CTE to include `max_attempts`, replaced the invalid `absurd.current_time()` call, rewrote `pgconductor.invoke`, and updated the `orchestrators` table/heartbeat so `shutdown_signal` is managed via a version-aware CTE (plus `sweep_orchestrators`) before migrations run.  
- `migrations/0000000000_migrations.sql`: reverted to the lean `schema_migrations (version, name, applied_at, breaking)` table with no RPC helpers—TypeScript is once again the single source of truth for migration SQL.  
- `packages/pgconductor-js/src/database-client.ts`: consolidates migration-specific queries (installed version lookup, advisory-locked migration application, sweeping, orchestrator counts), making the SDK easier to test and reason about.  
- `packages/pgconductor-js/src/schema-manager.ts`: now delegates directly to `DatabaseClient` helpers, loops with fixed backoff, and only sweeps/waits when the next migration is breaking.  
- `packages/pgconductor-js/src/Orchestrator.ts`: startup threads the abort signal into `ensureLatest`, so the database-driven migration loop can be interrupted cleanly before workers launch.
